use anchor_lang::prelude::*;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use chrono::{DateTime, Utc};
use crate::errors::VaultError;
use crate::security::cve_scanner::{Advisory, Severity};

/// Tracks and manages vulnerability lifecycle
#[derive(Debug, Clone)]
pub struct VulnerabilityTracker {
    tracked_vulnerabilities: HashMap<String, TrackedVulnerability>,
    mitigation_strategies: HashMap<String, MitigationStrategy>,
    risk_assessments: HashMap<String, RiskAssessment>,
}

/// A vulnerability being tracked through its lifecycle
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TrackedVulnerability {
    pub advisory: Advisory,
    pub discovery_date: DateTime<Utc>,
    pub status: VulnerabilityStatus,
    pub affected_components: Vec<String>,
    pub mitigation_plan: Option<MitigationPlan>,
    pub risk_score: f32,
    pub business_impact: BusinessImpact,
    pub timeline: Vec<VulnerabilityEvent>,
}

/// Current status of a tracked vulnerability
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum VulnerabilityStatus {
    New,
    Triaged,
    InProgress,
    Mitigated,
    Resolved,
    Accepted, // Risk accepted, no fix planned
    Deferred, // Fix planned for future release
}

/// Mitigation strategy for a vulnerability
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MitigationStrategy {
    pub strategy_type: MitigationType,
    pub description: String,
    pub implementation_effort: ImplementationEffort,
    pub effectiveness_score: f32, // 0.0 to 1.0
    pub side_effects: Vec<String>,
    pub prerequisites: Vec<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum MitigationType {
    DependencyUpdate,
    DependencyReplacement,
    CodeModification,
    ConfigurationChange,
    ArchitecturalChange,
    ProcessChange,
    AcceptRisk,
}

/// Implementation effort estimation
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ImplementationEffort {
    Trivial,    // < 1 hour
    Low,        // 1-8 hours
    Medium,     // 1-3 days
    High,       // 1-2 weeks
    VeryHigh,   // > 2 weeks
}

/// Business impact assessment
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BusinessImpact {
    pub confidentiality_impact: ImpactLevel,
    pub integrity_impact: ImpactLevel,
    pub availability_impact: ImpactLevel,
    pub financial_impact: FinancialImpact,
    pub regulatory_impact: RegulatoryImpact,
    pub reputation_impact: ImpactLevel,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ImpactLevel {
    None,
    Low,
    Medium,
    High,
    Critical,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FinancialImpact {
    pub estimated_cost_usd: Option<u64>,
    pub revenue_impact: ImpactLevel,
    pub operational_cost_impact: ImpactLevel,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RegulatoryImpact {
    pub compliance_violation: bool,
    pub reporting_required: bool,
    pub affected_regulations: Vec<String>,
}

/// Mitigation plan for addressing a vulnerability
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MitigationPlan {
    pub strategy: MitigationStrategy,
    pub timeline: MitigationTimeline,
    pub assigned_team: String,
    pub dependencies: Vec<String>,
    pub success_criteria: Vec<String>,
    pub rollback_plan: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MitigationTimeline {
    pub start_date: DateTime<Utc>,
    pub target_completion: DateTime<Utc>,
    pub milestones: Vec<Milestone>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Milestone {
    pub name: String,
    pub description: String,
    pub target_date: DateTime<Utc>,
    pub completed: bool,
    pub completion_date: Option<DateTime<Utc>>,
}

/// Risk assessment for a vulnerability
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RiskAssessment {
    pub vulnerability_id: String,
    pub likelihood: LikelihoodLevel,
    pub impact: ImpactLevel,
    pub risk_score: f32, // Calculated from likelihood and impact
    pub risk_level: RiskLevel,
    pub attack_vectors: Vec<AttackVector>,
    pub mitigating_factors: Vec<String>,
    pub aggravating_factors: Vec<String>,
    pub assessment_date: DateTime<Utc>,
    pub assessor: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum LikelihoodLevel {
    VeryLow,    // < 5%
    Low,        // 5-25%
    Medium,     // 25-75%
    High,       // 75-95%
    VeryHigh,   // > 95%
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum RiskLevel {
    Low,
    Medium,
    High,
    Critical,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AttackVector {
    pub vector_type: AttackVectorType,
    pub description: String,
    pub prerequisites: Vec<String>,
    pub difficulty: AttackDifficulty,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum AttackVectorType {
    Network,
    Local,
    Physical,
    SocialEngineering,
    SupplyChain,
    Insider,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum AttackDifficulty {
    Trivial,
    Easy,
    Medium,
    Hard,
    VeryHard,
}

/// Event in vulnerability lifecycle
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct VulnerabilityEvent {
    pub event_type: EventType,
    pub timestamp: DateTime<Utc>,
    pub description: String,
    pub actor: String,
    pub metadata: HashMap<String, String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum EventType {
    Discovered,
    Triaged,
    MitigationStarted,
    MitigationCompleted,
    Verified,
    Closed,
    Reopened,
    RiskAccepted,
    EscalatedToManagement,
}

impl VulnerabilityTracker {
    /// Create a new vulnerability tracker
    pub fn new() -> Self {
        Self {
            tracked_vulnerabilities: HashMap::new(),
            mitigation_strategies: HashMap::new(),
            risk_assessments: HashMap::new(),
        }
    }

    /// Track a new vulnerability
    pub fn track_vulnerability(&mut self, advisory: Advisory) -> Result<String> {
        let vulnerability_id = advisory.id.clone();
        
        msg!("Tracking new vulnerability: {}", vulnerability_id);
        
        let tracked = TrackedVulnerability {
            discovery_date: Utc::now(),
            status: VulnerabilityStatus::New,
            affected_components: self.identify_affected_components(&advisory)?,
            mitigation_plan: None,
            risk_score: self.calculate_initial_risk_score(&advisory),
            business_impact: self.assess_business_impact(&advisory)?,
            timeline: vec![VulnerabilityEvent {
                event_type: EventType::Discovered,
                timestamp: Utc::now(),
                description: format!("Vulnerability discovered: {}", advisory.title),
                actor: "system".to_string(),
                metadata: HashMap::new(),
            }],
            advisory,
        };
        
        self.tracked_vulnerabilities.insert(vulnerability_id.clone(), tracked);
        
        // Perform initial risk assessment
        self.perform_risk_assessment(&vulnerability_id)?;
        
        Ok(vulnerability_id)
    }

    /// Update vulnerability status
    pub fn update_status(&mut self, vulnerability_id: &str, new_status: VulnerabilityStatus, actor: &str) -> Result<()> {
        let vulnerability = self.tracked_vulnerabilities
            .get_mut(vulnerability_id)
            .ok_or(VaultError::SecurityViolation("Vulnerability not found".to_string()))?;
        
        let old_status = vulnerability.status.clone();
        vulnerability.status = new_status.clone();
        
        // Add timeline event
        vulnerability.timeline.push(VulnerabilityEvent {
            event_type: match new_status {
                VulnerabilityStatus::Triaged => EventType::Triaged,
                VulnerabilityStatus::InProgress => EventType::MitigationStarted,
                VulnerabilityStatus::Mitigated => EventType::MitigationCompleted,
                VulnerabilityStatus::Resolved => EventType::Closed,
                VulnerabilityStatus::Accepted => EventType::RiskAccepted,
                _ => EventType::Triaged,
            },
            timestamp: Utc::now(),
            description: format!("Status changed from {:?} to {:?}", old_status, new_status),
            actor: actor.to_string(),
            metadata: HashMap::new(),
        });
        
        msg!("Updated vulnerability {} status to {:?}", vulnerability_id, new_status);
        Ok(())
    }

    /// Create mitigation plan for a vulnerability
    pub fn create_mitigation_plan(&mut self, vulnerability_id: &str, strategy: MitigationStrategy, assigned_team: &str) -> Result<()> {
        let vulnerability = self.tracked_vulnerabilities
            .get_mut(vulnerability_id)
            .ok_or(VaultError::SecurityViolation("Vulnerability not found".to_string()))?;
        
        let timeline = MitigationTimeline {
            start_date: Utc::now(),
            target_completion: self.calculate_target_completion(&strategy, &vulnerability.advisory.severity),
            milestones: self.generate_milestones(&strategy),
        };
        
        let plan = MitigationPlan {
            strategy: strategy.clone(),
            timeline,
            assigned_team: assigned_team.to_string(),
            dependencies: vec![],
            success_criteria: self.generate_success_criteria(&strategy),
            rollback_plan: self.generate_rollback_plan(&strategy),
        };
        
        vulnerability.mitigation_plan = Some(plan);
        vulnerability.status = VulnerabilityStatus::InProgress;
        
        // Store strategy for reuse
        self.mitigation_strategies.insert(
            format!("{}_{}", vulnerability_id, strategy.strategy_type as u8),
            strategy
        );
        
        msg!("Created mitigation plan for vulnerability: {}", vulnerability_id);
        Ok(())
    }

    /// Perform risk assessment for a vulnerability
    pub fn perform_risk_assessment(&mut self, vulnerability_id: &str) -> Result<RiskAssessment> {
        let vulnerability = self.tracked_vulnerabilities
            .get(vulnerability_id)
            .ok_or(VaultError::SecurityViolation("Vulnerability not found".to_string()))?;
        
        let likelihood = self.assess_likelihood(&vulnerability.advisory)?;
        let impact = self.assess_impact(&vulnerability.business_impact);
        let risk_score = self.calculate_risk_score(likelihood.clone(), impact.clone());
        let risk_level = self.determine_risk_level(risk_score);
        
        let assessment = RiskAssessment {
            vulnerability_id: vulnerability_id.to_string(),
            likelihood,
            impact,
            risk_score,
            risk_level,
            attack_vectors: self.identify_attack_vectors(&vulnerability.advisory)?,
            mitigating_factors: self.identify_mitigating_factors(&vulnerability.advisory),
            aggravating_factors: self.identify_aggravating_factors(&vulnerability.advisory),
            assessment_date: Utc::now(),
            assessor: "automated_system".to_string(),
        };
        
        self.risk_assessments.insert(vulnerability_id.to_string(), assessment.clone());
        
        msg!("Risk assessment completed for {}: {:?} risk", vulnerability_id, assessment.risk_level);
        Ok(assessment)
    }

    /// Get vulnerabilities by status
    pub fn get_vulnerabilities_by_status(&self, status: VulnerabilityStatus) -> Vec<&TrackedVulnerability> {
        self.tracked_vulnerabilities
            .values()
            .filter(|v| std::mem::discriminant(&v.status) == std::mem::discriminant(&status))
            .collect()
    }

    /// Get high-risk vulnerabilities
    pub fn get_high_risk_vulnerabilities(&self) -> Vec<(&String, &TrackedVulnerability)> {
        self.tracked_vulnerabilities
            .iter()
            .filter(|(id, _)| {
                if let Some(assessment) = self.risk_assessments.get(*id) {
                    matches!(assessment.risk_level, RiskLevel::High | RiskLevel::Critical)
                } else {
                    false
                }
            })
            .collect()
    }

    /// Generate vulnerability report
    pub fn generate_report(&self) -> VulnerabilityReport {
        let total_vulnerabilities = self.tracked_vulnerabilities.len();
        let mut status_counts = HashMap::new();
        let mut severity_counts = HashMap::new();
        let mut risk_level_counts = HashMap::new();
        
        for vulnerability in self.tracked_vulnerabilities.values() {
            // Count by status
            let status_key = format!("{:?}", vulnerability.status);
            *status_counts.entry(status_key).or_insert(0) += 1;
            
            // Count by severity
            let severity_key = format!("{:?}", vulnerability.advisory.severity);
            *severity_counts.entry(severity_key).or_insert(0) += 1;
        }
        
        // Count by risk level
        for assessment in self.risk_assessments.values() {
            let risk_key = format!("{:?}", assessment.risk_level);
            *risk_level_counts.entry(risk_key).or_insert(0) += 1;
        }
        
        VulnerabilityReport {
            total_vulnerabilities,
            status_distribution: status_counts,
            severity_distribution: severity_counts,
            risk_level_distribution: risk_level_counts,
            high_risk_count: self.get_high_risk_vulnerabilities().len(),
            overdue_mitigations: self.count_overdue_mitigations(),
            report_date: Utc::now(),
        }
    }

    // Private helper methods
    fn identify_affected_components(&self, advisory: &Advisory) -> Result<Vec<String>> {
        let mut components = Vec::new();
        
        for affected_crate in &advisory.affected_crates {
            // Map crate names to system components
            match affected_crate.name.as_str() {
                "curve25519-dalek" => components.push("cryptography".to_string()),
                "borsh" => components.push("serialization".to_string()),
                "derivative" => components.push("code_generation".to_string()),
                "paste" => components.push("macros".to_string()),
                _ => components.push("unknown".to_string()),
            }
        }
        
        Ok(components)
    }

    fn calculate_initial_risk_score(&self, advisory: &Advisory) -> f32 {
        match advisory.severity {
            Severity::Low => 2.5,
            Severity::Medium => 5.0,
            Severity::High => 7.5,
            Severity::Critical => 10.0,
        }
    }

    fn assess_business_impact(&self, advisory: &Advisory) -> Result<BusinessImpact> {
        // Simplified business impact assessment
        let impact_level = match advisory.severity {
            Severity::Critical => ImpactLevel::Critical,
            Severity::High => ImpactLevel::High,
            Severity::Medium => ImpactLevel::Medium,
            Severity::Low => ImpactLevel::Low,
        };
        
        Ok(BusinessImpact {
            confidentiality_impact: impact_level.clone(),
            integrity_impact: impact_level.clone(),
            availability_impact: impact_level.clone(),
            financial_impact: FinancialImpact {
                estimated_cost_usd: None,
                revenue_impact: impact_level.clone(),
                operational_cost_impact: impact_level.clone(),
            },
            regulatory_impact: RegulatoryImpact {
                compliance_violation: matches!(advisory.severity, Severity::Critical | Severity::High),
                reporting_required: matches!(advisory.severity, Severity::Critical),
                affected_regulations: vec![],
            },
            reputation_impact: impact_level,
        })
    }

    fn assess_likelihood(&self, advisory: &Advisory) -> Result<LikelihoodLevel> {
        // Assess likelihood based on various factors
        Ok(match advisory.severity {
            Severity::Critical => LikelihoodLevel::High,
            Severity::High => LikelihoodLevel::Medium,
            Severity::Medium => LikelihoodLevel::Low,
            Severity::Low => LikelihoodLevel::VeryLow,
        })
    }

    fn assess_impact(&self, business_impact: &BusinessImpact) -> ImpactLevel {
        // Return the highest impact level across all categories
        [
            &business_impact.confidentiality_impact,
            &business_impact.integrity_impact,
            &business_impact.availability_impact,
            &business_impact.reputation_impact,
        ].iter().max().unwrap().clone()
    }

    fn calculate_risk_score(&self, likelihood: LikelihoodLevel, impact: ImpactLevel) -> f32 {
        let likelihood_score = match likelihood {
            LikelihoodLevel::VeryLow => 1.0,
            LikelihoodLevel::Low => 2.0,
            LikelihoodLevel::Medium => 3.0,
            LikelihoodLevel::High => 4.0,
            LikelihoodLevel::VeryHigh => 5.0,
        };
        
        let impact_score = match impact {
            ImpactLevel::None => 0.0,
            ImpactLevel::Low => 1.0,
            ImpactLevel::Medium => 2.0,
            ImpactLevel::High => 3.0,
            ImpactLevel::Critical => 4.0,
        };
        
        likelihood_score * impact_score
    }

    fn determine_risk_level(&self, risk_score: f32) -> RiskLevel {
        match risk_score {
            0.0..=4.0 => RiskLevel::Low,
            4.1..=8.0 => RiskLevel::Medium,
            8.1..=15.0 => RiskLevel::High,
            _ => RiskLevel::Critical,
        }
    }

    fn identify_attack_vectors(&self, advisory: &Advisory) -> Result<Vec<AttackVector>> {
        // Simplified attack vector identification
        let mut vectors = Vec::new();
        
        if advisory.description.contains("timing") {
            vectors.push(AttackVector {
                vector_type: AttackVectorType::Local,
                description: "Timing side-channel attack".to_string(),
                prerequisites: vec!["Local access".to_string(), "Precise timing measurement".to_string()],
                difficulty: AttackDifficulty::Hard,
            });
        }
        
        if advisory.description.contains("parsing") || advisory.description.contains("deserialization") {
            vectors.push(AttackVector {
                vector_type: AttackVectorType::Network,
                description: "Malicious input parsing".to_string(),
                prerequisites: vec!["Ability to provide input".to_string()],
                difficulty: AttackDifficulty::Medium,
            });
        }
        
        Ok(vectors)
    }

    fn identify_mitigating_factors(&self, advisory: &Advisory) -> Vec<String> {
        let mut factors = Vec::new();
        
        if advisory.description.contains("requires local access") {
            factors.push("Requires local system access".to_string());
        }
        
        if advisory.description.contains("specific conditions") {
            factors.push("Requires specific exploitation conditions".to_string());
        }
        
        factors
    }

    fn identify_aggravating_factors(&self, advisory: &Advisory) -> Vec<String> {
        let mut factors = Vec::new();
        
        if advisory.severity == Severity::Critical {
            factors.push("Critical severity vulnerability".to_string());
        }
        
        if advisory.solution.is_none() {
            factors.push("No known fix available".to_string());
        }
        
        factors
    }

    fn calculate_target_completion(&self, strategy: &MitigationStrategy, severity: &Severity) -> DateTime<Utc> {
        let days_to_add = match (severity, &strategy.implementation_effort) {
            (Severity::Critical, _) => 1,  // Critical: 1 day
            (Severity::High, ImplementationEffort::Trivial) => 1,
            (Severity::High, ImplementationEffort::Low) => 3,
            (Severity::High, _) => 7,      // High: 1 week max
            (Severity::Medium, _) => 30,   // Medium: 1 month
            (Severity::Low, _) => 90,      // Low: 3 months
        };
        
        Utc::now() + chrono::Duration::days(days_to_add)
    }

    fn generate_milestones(&self, strategy: &MitigationStrategy) -> Vec<Milestone> {
        match strategy.strategy_type {
            MitigationType::DependencyUpdate => vec![
                Milestone {
                    name: "Test update".to_string(),
                    description: "Test dependency update in development environment".to_string(),
                    target_date: Utc::now() + chrono::Duration::days(1),
                    completed: false,
                    completion_date: None,
                },
                Milestone {
                    name: "Deploy update".to_string(),
                    description: "Deploy updated dependency to production".to_string(),
                    target_date: Utc::now() + chrono::Duration::days(3),
                    completed: false,
                    completion_date: None,
                },
            ],
            _ => vec![],
        }
    }

    fn generate_success_criteria(&self, strategy: &MitigationStrategy) -> Vec<String> {
        match strategy.strategy_type {
            MitigationType::DependencyUpdate => vec![
                "Vulnerability no longer detected in security scans".to_string(),
                "All tests pass with updated dependency".to_string(),
                "No regression in functionality".to_string(),
            ],
            _ => vec!["Vulnerability successfully mitigated".to_string()],
        }
    }

    fn generate_rollback_plan(&self, strategy: &MitigationStrategy) -> Option<String> {
        match strategy.strategy_type {
            MitigationType::DependencyUpdate => Some(
                "Revert to previous dependency version if issues arise".to_string()
            ),
            _ => None,
        }
    }

    fn count_overdue_mitigations(&self) -> usize {
        let now = Utc::now();
        self.tracked_vulnerabilities
            .values()
            .filter(|v| {
                if let Some(plan) = &v.mitigation_plan {
                    plan.timeline.target_completion < now && 
                    !matches!(v.status, VulnerabilityStatus::Resolved | VulnerabilityStatus::Mitigated)
                } else {
                    false
                }
            })
            .count()
    }
}

/// Vulnerability tracking report
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct VulnerabilityReport {
    pub total_vulnerabilities: usize,
    pub status_distribution: HashMap<String, usize>,
    pub severity_distribution: HashMap<String, usize>,
    pub risk_level_distribution: HashMap<String, usize>,
    pub high_risk_count: usize,
    pub overdue_mitigations: usize,
    pub report_date: DateTime<Utc>,
}