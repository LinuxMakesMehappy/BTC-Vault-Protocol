'use client'; \n\nimport React, { createContext, useContext, useState, useEffect } from 'react'; \nimport { useWallet, useConnection } from '@solana/wallet-adapter-react'; \nimport { PhantomWalletAdapter, SolflareWalletAdapter } from '@solana/wallet-adapter-wallets'; \nimport { VaultClient } from '../lib/vault-client'; \nimport { VaultConfig, WalletState } from '../types/vault'; \nimport toast from 'react-hot-toast'; \n\ninterface VaultContextType { \n  client: VaultClient | null; \n  walletState: WalletState; \n  connect: () => Promise<void>; \n  disconnect: () => Promise<void>; \n  isLoading: boolean; \n } \n\nconst VaultContext = createContext<VaultContextType | undefined>(undefined); \n\nconst vaultConfig: VaultConfig = { \n  network: (process.env.NEXT_PUBLIC_SOLANA_NETWORK as any) || 'devnet', \n  programId: process.env.NEXT_PUBLIC_VAULT_PROGRAM_ID || 'VaultProgram1111111111111111111111111111111', \n  rpcEndpoint: process.env.NEXT_PUBLIC_RPC_ENDPOINT || 'https://api.devnet.solana.com', \n  commitment: 'confirmed', \n  features: { \n    payments: true, \n    rewards: true, \n    kyc: true, \n    multisig: true, \n    staking: true, \n }, \n }; \n\nexport function VaultWalletProvider({ children }: { children: React.ReactNode }) { \n  const { wallet, publicKey, connected, connecting, disconnect: walletDisconnect } = useWallet(); \n  const { connection } = useConnection(); \n  const [client, setClient] = useState<VaultClient | null>(null); \n  const [isLoading, setIsLoading] = useState(false); \n\n  const walletState: WalletState = { \n    connected, \n    connecting, \n    publicKey: publicKey?.toString() || null, \n    balance: 0, // Will be updated by client\n    network: vaultConfig.network,\n  };\n\n  const connect = async () => {\n    if (!wallet || !publicKey) {\n      toast.error('Please select a wallet first');\n      return;\n    }\n\n    setIsLoading(true);\n    try {\n      const vaultClient = new VaultClient(vaultConfig);\n      await vaultClient.connectWallet(wallet.adapter as any);\n      setClient(vaultClient);\n      toast.success('Wallet connected successfully');\n    } catch (error) {\n      console.error('Failed to connect wallet:', error);\n      toast.error('Failed to connect wallet');\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const disconnect = async () => {\n    setIsLoading(true);\n    try {\n      if (client) {\n        await client.disconnectWallet();\n      }\n      await walletDisconnect();\n      setClient(null);\n      toast.success('Wallet disconnected');\n    } catch (error) {\n      console.error('Failed to disconnect wallet:', error);\n      toast.error('Failed to disconnect wallet');\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  // Auto-connect when wallet is connected\n  useEffect(() => {\n    if (connected && wallet && publicKey && !client) {\n      connect();\n    }\n  }, [connected, wallet, publicKey]);\n\n  // Clean up client when wallet disconnects\n  useEffect(() => {\n    if (!connected && client) {\n      setClient(null);\n    }\n  }, [connected]);\n\n  return (\n    <VaultContext.Provider value={{\n      client,\n      walletState,\n      connect,\n      disconnect,\n      isLoading,\n    }}>\n      {children}\n    </VaultContext.Provider>\n  );\n}\n\nexport function useVault() {\n  const context = useContext(VaultContext);\n  if (context === undefined) {\n    throw new Error('useVault must be used within a VaultWalletProvider');\n  }\n  return context;\n}\n"